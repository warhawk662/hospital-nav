import "./chunk-5WRI5ZAA.js";

// node_modules/ngraph.events/index.js
function eventify(subject) {
  validateSubject(subject);
  const eventsStorage = createEventsStorage(subject);
  subject.on = eventsStorage.on;
  subject.off = eventsStorage.off;
  subject.fire = eventsStorage.fire;
  return subject;
}
function createEventsStorage(subject) {
  let registeredEvents = /* @__PURE__ */ Object.create(null);
  return {
    on: function(eventName, callback, ctx) {
      if (typeof callback !== "function") {
        throw new Error("callback is expected to be a function");
      }
      let handlers = registeredEvents[eventName];
      if (!handlers) {
        handlers = registeredEvents[eventName] = [];
      }
      handlers.push({ callback, ctx });
      return subject;
    },
    off: function(eventName, callback) {
      const wantToRemoveAll = typeof eventName === "undefined";
      if (wantToRemoveAll) {
        registeredEvents = /* @__PURE__ */ Object.create(null);
        return subject;
      }
      if (registeredEvents[eventName]) {
        const deleteAllCallbacksForEvent = typeof callback !== "function";
        if (deleteAllCallbacksForEvent) {
          delete registeredEvents[eventName];
        } else {
          const callbacks = registeredEvents[eventName];
          for (let i = 0; i < callbacks.length; ++i) {
            if (callbacks[i].callback === callback) {
              callbacks.splice(i, 1);
            }
          }
        }
      }
      return subject;
    },
    fire: function(eventName) {
      const callbacks = registeredEvents[eventName];
      if (!callbacks) {
        return subject;
      }
      let fireArguments;
      if (arguments.length > 1) {
        fireArguments = Array.prototype.slice.call(arguments, 1);
      }
      for (let i = 0; i < callbacks.length; ++i) {
        const callbackInfo = callbacks[i];
        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);
      }
      return subject;
    }
  };
}
function validateSubject(subject) {
  if (!subject) {
    throw new Error("Eventify cannot use falsy object as events subject");
  }
  const reservedWords = ["on", "fire", "off"];
  for (let i = 0; i < reservedWords.length; ++i) {
    if (subject.hasOwnProperty(reservedWords[i])) {
      throw new Error("Subject cannot be eventified, since it already has property '" + reservedWords[i] + "'");
    }
  }
}

// node_modules/ngraph.graph/index.js
var ngraph_default = createGraph;
function createGraph(options) {
  options = options || {};
  if ("uniqueLinkId" in options) {
    console.warn(
      "ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n",
      "\n",
      "Note: there is also change in default behavior: From now on each graph\nis considered to be not a multigraph by default (each edge is unique)."
    );
    options.multigraph = options.uniqueLinkId;
  }
  if (options.multigraph === void 0) options.multigraph = false;
  if (typeof Map !== "function") {
    throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
  }
  var nodes = /* @__PURE__ */ new Map();
  var links = /* @__PURE__ */ new Map();
  var multiEdges = {};
  var suspendEvents = 0;
  var createLink = options.multigraph ? createUniqueLink : createSingleLink, changes = [], recordLinkChange = noop, recordNodeChange = noop, enterModification = noop, exitModification = noop;
  var graphPart = {
    /**
     * Sometimes duck typing could be slow. Giving clients a hint about data structure
     * via explicit version number here:
     */
    version: 20,
    /**
     * Adds node to the graph. If node with given id already exists in the graph
     * its data is extended with whatever comes in 'data' argument.
     *
     * @param nodeId the node's identifier. A string or number is preferred.
     * @param [data] additional data for the node being added. If node already
     *   exists its data object is augmented with the new one.
     *
     * @return {node} The newly added node or node with given id if it already exists.
     */
    addNode,
    /**
     * Adds a link to the graph. The function always create a new
     * link between two nodes. If one of the nodes does not exists
     * a new node is created.
     *
     * @param fromId link start node id;
     * @param toId link end node id;
     * @param [data] additional data to be set on the new link;
     *
     * @return {link} The newly created link
     */
    addLink,
    /**
     * Removes link from the graph. If link does not exist does nothing.
     *
     * @param link - object returned by addLink() or getLinks() methods.
     *
     * @returns true if link was removed; false otherwise.
     */
    removeLink,
    /**
     * Removes node with given id from the graph. If node does not exist in the graph
     * does nothing.
     *
     * @param nodeId node's identifier passed to addNode() function.
     *
     * @returns true if node was removed; false otherwise.
     */
    removeNode,
    /**
     * Gets node with given identifier. If node does not exist undefined value is returned.
     *
     * @param nodeId requested node identifier;
     *
     * @return {node} in with requested identifier or undefined if no such node exists.
     */
    getNode,
    /**
     * Gets number of nodes in this graph.
     *
     * @return number of nodes in the graph.
     */
    getNodeCount,
    /**
     * Gets total number of links in the graph.
     */
    getLinkCount,
    /**
     * Synonym for `getLinkCount()`
     */
    getEdgeCount: getLinkCount,
    /**
     * Synonym for `getLinkCount()`
     */
    getLinksCount: getLinkCount,
    /**
     * Synonym for `getNodeCount()`
     */
    getNodesCount: getNodeCount,
    /**
     * Gets all links (inbound and outbound) from the node with given id.
     * If node with given id is not found null is returned.
     *
     * @param nodeId requested node identifier.
     *
     * @return Set of links from and to requested node if such node exists;
     *   otherwise null is returned.
     */
    getLinks,
    /**
     * Invokes callback on each node of the graph.
     *
     * @param {Function(node)} callback Function to be invoked. The function
     *   is passed one argument: visited node.
     */
    forEachNode,
    /**
     * Invokes callback on every linked (adjacent) node to the given one.
     *
     * @param nodeId Identifier of the requested node.
     * @param {Function(node, link)} callback Function to be called on all linked nodes.
     *   The function is passed two parameters: adjacent node and link object itself.
     * @param oriented if true graph treated as oriented.
     */
    forEachLinkedNode,
    /**
     * Enumerates all links in the graph
     *
     * @param {Function(link)} callback Function to be called on all links in the graph.
     *   The function is passed one parameter: graph's link object.
     *
     * Link object contains at least the following fields:
     *  fromId - node id where link starts;
     *  toId - node id where link ends,
     *  data - additional data passed to graph.addLink() method.
     */
    forEachLink,
    /**
     * Suspend all notifications about graph changes until
     * endUpdate is called.
     */
    beginUpdate: enterModification,
    /**
     * Resumes all notifications about graph changes and fires
     * graph 'changed' event in case there are any pending changes.
     */
    endUpdate: exitModification,
    /**
     * Removes all nodes and links from the graph.
     */
    clear,
    /**
     * Detects whether there is a link between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     * NOTE: this function is synonym for getLink()
     *
     * @returns link if there is one. null otherwise.
     */
    hasLink: getLink,
    /**
     * Detects whether there is a node with given id
     * 
     * Operation complexity is O(1)
     * NOTE: this function is synonym for getNode()
     *
     * @returns node if there is one; Falsy value otherwise.
     */
    hasNode: getNode,
    /**
     * Gets an edge between two nodes.
     * Operation complexity is O(n) where n - number of links of a node.
     *
     * @param {string} fromId link start identifier
     * @param {string} toId link end identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLink,
    /**
     * Gets a link by its id.
     *
     * @param {string} linkId link identifier
     *
     * @returns link if there is one; undefined otherwise.
     */
    getLinkById
  };
  eventify(graphPart);
  monitorSubscribers();
  return graphPart;
  function monitorSubscribers() {
    var realOn = graphPart.on;
    graphPart.on = on;
    function on() {
      graphPart.beginUpdate = enterModification = enterModificationReal;
      graphPart.endUpdate = exitModification = exitModificationReal;
      recordLinkChange = recordLinkChangeReal;
      recordNodeChange = recordNodeChangeReal;
      graphPart.on = realOn;
      return realOn.apply(graphPart, arguments);
    }
  }
  function recordLinkChangeReal(link, changeType) {
    changes.push({
      link,
      changeType
    });
  }
  function recordNodeChangeReal(node, changeType) {
    changes.push({
      node,
      changeType
    });
  }
  function addNode(nodeId, data) {
    if (nodeId === void 0) {
      throw new Error("Invalid node identifier");
    }
    enterModification();
    var node = getNode(nodeId);
    if (!node) {
      node = new Node(nodeId, data);
      recordNodeChange(node, "add");
    } else {
      node.data = data;
      recordNodeChange(node, "update");
    }
    nodes.set(nodeId, node);
    exitModification();
    return node;
  }
  function getNode(nodeId) {
    return nodes.get(nodeId);
  }
  function removeNode(nodeId) {
    var node = getNode(nodeId);
    if (!node) {
      return false;
    }
    enterModification();
    var prevLinks = node.links;
    if (prevLinks) {
      prevLinks.forEach(removeLinkInstance);
      node.links = null;
    }
    nodes.delete(nodeId);
    recordNodeChange(node, "remove");
    exitModification();
    return true;
  }
  function addLink(fromId, toId, data) {
    enterModification();
    var fromNode = getNode(fromId) || addNode(fromId);
    var toNode = getNode(toId) || addNode(toId);
    var link = createLink(fromId, toId, data);
    var isUpdate = links.has(link.id);
    links.set(link.id, link);
    addLinkToNode(fromNode, link);
    if (fromId !== toId) {
      addLinkToNode(toNode, link);
    }
    recordLinkChange(link, isUpdate ? "update" : "add");
    exitModification();
    return link;
  }
  function createSingleLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    var prevLink = links.get(linkId);
    if (prevLink) {
      prevLink.data = data;
      return prevLink;
    }
    return new Link(fromId, toId, data, linkId);
  }
  function createUniqueLink(fromId, toId, data) {
    var linkId = makeLinkId(fromId, toId);
    var isMultiEdge = multiEdges.hasOwnProperty(linkId);
    if (isMultiEdge || getLink(fromId, toId)) {
      if (!isMultiEdge) {
        multiEdges[linkId] = 0;
      }
      var suffix = "@" + ++multiEdges[linkId];
      linkId = makeLinkId(fromId + suffix, toId + suffix);
    }
    return new Link(fromId, toId, data, linkId);
  }
  function getNodeCount() {
    return nodes.size;
  }
  function getLinkCount() {
    return links.size;
  }
  function getLinks(nodeId) {
    var node = getNode(nodeId);
    return node ? node.links : null;
  }
  function removeLink(link, otherId) {
    if (otherId !== void 0) {
      link = getLink(link, otherId);
    }
    return removeLinkInstance(link);
  }
  function removeLinkInstance(link) {
    if (!link) {
      return false;
    }
    if (!links.get(link.id)) return false;
    enterModification();
    links.delete(link.id);
    var fromNode = getNode(link.fromId);
    var toNode = getNode(link.toId);
    if (fromNode) {
      fromNode.links.delete(link);
    }
    if (toNode) {
      toNode.links.delete(link);
    }
    recordLinkChange(link, "remove");
    exitModification();
    return true;
  }
  function getLink(fromNodeId, toNodeId) {
    if (fromNodeId === void 0 || toNodeId === void 0) return void 0;
    return links.get(makeLinkId(fromNodeId, toNodeId));
  }
  function getLinkById(linkId) {
    if (linkId === void 0) return void 0;
    return links.get(linkId);
  }
  function clear() {
    enterModification();
    forEachNode(function(node) {
      removeNode(node.id);
    });
    exitModification();
  }
  function forEachLink(callback) {
    if (typeof callback === "function") {
      var valuesIterator = links.values();
      var nextValue = valuesIterator.next();
      while (!nextValue.done) {
        if (callback(nextValue.value)) {
          return true;
        }
        nextValue = valuesIterator.next();
      }
    }
  }
  function forEachLinkedNode(nodeId, callback, oriented) {
    var node = getNode(nodeId);
    if (node && node.links && typeof callback === "function") {
      if (oriented) {
        return forEachOrientedLink(node.links, nodeId, callback);
      } else {
        return forEachNonOrientedLink(node.links, nodeId, callback);
      }
    }
  }
  function forEachNonOrientedLink(links2, nodeId, callback) {
    var quitFast;
    var valuesIterator = links2.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      var link = nextValue.value;
      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;
      quitFast = callback(nodes.get(linkedNodeId), link);
      if (quitFast) {
        return true;
      }
      nextValue = valuesIterator.next();
    }
  }
  function forEachOrientedLink(links2, nodeId, callback) {
    var quitFast;
    var valuesIterator = links2.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      var link = nextValue.value;
      if (link.fromId === nodeId) {
        quitFast = callback(nodes.get(link.toId), link);
        if (quitFast) {
          return true;
        }
      }
      nextValue = valuesIterator.next();
    }
  }
  function noop() {
  }
  function enterModificationReal() {
    suspendEvents += 1;
  }
  function exitModificationReal() {
    suspendEvents -= 1;
    if (suspendEvents === 0 && changes.length > 0) {
      graphPart.fire("changed", changes);
      changes.length = 0;
    }
  }
  function forEachNode(callback) {
    if (typeof callback !== "function") {
      throw new Error("Function is expected to iterate over graph nodes. You passed " + callback);
    }
    var valuesIterator = nodes.values();
    var nextValue = valuesIterator.next();
    while (!nextValue.done) {
      if (callback(nextValue.value)) {
        return true;
      }
      nextValue = valuesIterator.next();
    }
  }
}
function Node(id, data) {
  this.id = id;
  this.links = null;
  this.data = data;
}
function addLinkToNode(node, link) {
  if (node.links) {
    node.links.add(link);
  } else {
    node.links = /* @__PURE__ */ new Set([link]);
  }
}
function Link(fromId, toId, data, id) {
  this.fromId = fromId;
  this.toId = toId;
  this.data = data;
  this.id = id;
}
function makeLinkId(fromId, toId) {
  return fromId.toString() + "ðŸ‘‰ " + toId.toString();
}
export {
  ngraph_default as default
};
//# sourceMappingURL=ngraph__graph.js.map
